WEBVTT
Kind: captions
Language: en

00:00:12.160 --> 00:00:15.160
So, people argue vigorously about the definition of life.

00:00:15.160 --> 00:00:20.160
They ask if it should have reproduction in it, or metabolism, or evolution.

00:00:20.160 --> 00:00:22.160
And I don't know the answer to that, so I'm not going to tell you.

00:00:22.160 --> 00:00:25.160
I will say that life involves computation.

00:00:25.160 --> 00:00:27.160
So this is a computer program.

00:00:27.160 --> 00:00:30.160
Booted up in a cell, the program would execute,

00:00:30.160 --> 00:00:33.160
and it could result in this person;

00:00:33.160 --> 00:00:36.160
or with a small change, it could result in this person;

00:00:36.160 --> 00:00:38.160
or another small change, this person;

00:00:38.160 --> 00:00:41.160
or with a larger change, this dog,

00:00:41.160 --> 00:00:43.160
or this tree, or this whale.

00:00:43.160 --> 00:00:45.160
So now, if you take this metaphor

00:00:45.160 --> 00:00:47.160
[of] genome as program seriously,

00:00:47.160 --> 00:00:49.160
you have to consider that Chris Anderson

00:00:49.160 --> 00:00:52.160
is a computer-fabricated artifact, as is Jim Watson,

00:00:52.160 --> 00:00:55.160
Craig Venter, as are all of us.

00:00:55.160 --> 00:00:57.160
And in convincing yourself that this metaphor is true,

00:00:57.160 --> 00:00:59.160
there are lots of similarities between genetic programs

00:00:59.160 --> 00:01:02.160
and computer programs that could help to convince you.

00:01:02.160 --> 00:01:04.160
But one, to me, that's most compelling

00:01:04.160 --> 00:01:07.160
is the peculiar sensitivity to small changes

00:01:07.160 --> 00:01:10.160
that can make large changes in biological development -- the output.

00:01:10.160 --> 00:01:12.160
A small mutation can take a two-wing fly

00:01:12.160 --> 00:01:13.160
and make it a four-wing fly.

00:01:13.160 --> 00:01:17.160
Or it could take a fly and put legs where its antennae should be.

00:01:17.160 --> 00:01:19.160
Or if you're familiar with "The Princess Bride,"

00:01:19.160 --> 00:01:21.160
it could create a six-fingered man.

00:01:21.160 --> 00:01:23.160
Now, a hallmark of computer programs

00:01:23.160 --> 00:01:26.160
is just this kind of sensitivity to small changes.

00:01:26.160 --> 00:01:28.160
If your bank account's one dollar, and you flip a single bit,

00:01:28.160 --> 00:01:30.160
you could end up with a thousand dollars.

00:01:30.160 --> 00:01:33.160
So these small changes are things that I think

00:01:33.160 --> 00:01:35.160
that -- they indicate to us that a complicated computation

00:01:35.160 --> 00:01:39.160
in development is underlying these amplified, large changes.

00:01:39.160 --> 00:01:45.160
So now, all of this indicates that there are molecular programs underlying biology,

00:01:45.160 --> 00:01:49.160
and it shows the power of molecular programs -- biology does.

00:01:49.160 --> 00:01:51.160
And what I want to do is write molecular programs,

00:01:51.160 --> 00:01:53.160
potentially to build technology.

00:01:53.160 --> 00:01:54.160
And there are a lot of people doing this,

00:01:54.160 --> 00:01:57.160
a lot of synthetic biologists doing this, like Craig Venter.

00:01:57.160 --> 00:01:59.160
And they concentrate on using cells.

00:01:59.160 --> 00:02:01.160
They're cell-oriented.

00:02:01.160 --> 00:02:03.160
So my friends, molecular programmers, and I

00:02:03.160 --> 00:02:05.160
have a sort of biomolecule-centric approach.

00:02:05.160 --> 00:02:08.160
We're interested in using DNA, RNA and protein,

00:02:08.160 --> 00:02:11.160
and building new languages for building things from the bottom up,

00:02:11.160 --> 00:02:12.160
using biomolecules,

00:02:12.160 --> 00:02:15.160
potentially having nothing to do with biology.

00:02:15.160 --> 00:02:19.160
So, these are all the machines in a cell.

00:02:19.160 --> 00:02:21.160
There's a camera.

00:02:21.160 --> 00:02:22.160
There's the solar panels of the cell,

00:02:22.160 --> 00:02:24.160
some switches that turn your genes on and off,

00:02:24.160 --> 00:02:27.160
the girders of the cell, motors that move your muscles.

00:02:27.160 --> 00:02:29.160
My little group of molecular programmers

00:02:29.160 --> 00:02:33.160
are trying to refashion all of these parts from DNA.

00:02:33.160 --> 00:02:35.160
We're not DNA zealots, but DNA is the cheapest,

00:02:35.160 --> 00:02:38.160
easiest to understand and easy to program material to do this.

00:02:38.160 --> 00:02:40.160
And as other things become easier to use --

00:02:40.160 --> 00:02:43.160
maybe protein -- we'll work with those.

00:02:43.160 --> 00:02:45.160
If we succeed, what will molecular programming look like?

00:02:45.160 --> 00:02:47.160
You're going to sit in front of your computer.

00:02:47.160 --> 00:02:49.160
You're going to design something like a cell phone,

00:02:49.160 --> 00:02:51.160
and in a high-level language, you'll describe that cell phone.

00:02:51.160 --> 00:02:53.160
Then you're going to have a compiler

00:02:53.160 --> 00:02:54.160
that's going to take that description

00:02:54.160 --> 00:02:56.160
and it's going to turn it into actual molecules

00:02:56.160 --> 00:02:58.160
that can be sent to a synthesizer

00:02:58.160 --> 00:03:01.160
and that synthesizer will pack those molecules into a seed.

00:03:01.160 --> 00:03:04.160
And what happens if you water and feed that seed appropriately,

00:03:04.160 --> 00:03:06.160
is it will do a developmental computation,

00:03:06.160 --> 00:03:09.160
a molecular computation, and it'll build an electronic computer.

00:03:09.160 --> 00:03:11.160
And if I haven't revealed my prejudices already,

00:03:12.160 --> 00:03:14.160
I think that life has been about molecular computers

00:03:14.160 --> 00:03:16.160
building electrochemical computers,

00:03:16.160 --> 00:03:18.160
building electronic computers,

00:03:18.160 --> 00:03:20.160
which together with electrochemical computers

00:03:20.160 --> 00:03:22.160
will build new molecular computers,

00:03:22.160 --> 00:03:25.160
which will build new electronic computers, and so forth.

00:03:25.160 --> 00:03:26.160
And if you buy all of this,

00:03:26.160 --> 00:03:28.160
and you think life is about computation, as I do,

00:03:28.160 --> 00:03:31.160
then you look at big questions through the eyes of a computer scientist.

00:03:31.160 --> 00:03:35.160
So one big question is, how does a baby know when to stop growing?

00:03:35.160 --> 00:03:37.160
And for molecular programming,

00:03:37.160 --> 00:03:39.160
the question is how does your cell phone know when to stop growing?

00:03:39.160 --> 00:03:40.160
(Laughter)

00:03:40.160 --> 00:03:43.160
Or how does a computer program know when to stop running?

00:03:43.160 --> 00:03:46.160
Or more to the point, how do you know if a program will ever stop?

00:03:46.160 --> 00:03:48.160
There are other questions like this, too.

00:03:48.160 --> 00:03:50.160
One of them is Craig Venter's question.

00:03:50.160 --> 00:03:52.160
Turns out I think he's actually a computer scientist.

00:03:52.160 --> 00:03:55.160
He asked, how big is the minimal genome

00:03:55.160 --> 00:03:57.160
that will give me a functioning microorganism?

00:03:57.160 --> 00:03:59.160
How few genes can I use?

00:03:59.160 --> 00:04:01.160
This is exactly analogous to the question,

00:04:01.160 --> 00:04:02.160
what's the smallest program I can write

00:04:02.160 --> 00:04:04.160
that will act exactly like Microsoft Word?

00:04:04.160 --> 00:04:05.160
(Laughter)

00:04:05.160 --> 00:04:09.160
And just as he's writing, you know, bacteria that will be smaller,

00:04:09.160 --> 00:04:10.160
he's writing genomes that will work,

00:04:10.160 --> 00:04:12.160
we could write smaller programs

00:04:12.160 --> 00:04:14.160
that would do what Microsoft Word does.

00:04:14.160 --> 00:04:16.160
But for molecular programming, our question is,

00:04:16.160 --> 00:04:20.160
how many molecules do we need to put in that seed to get a cell phone?

00:04:20.160 --> 00:04:22.160
What's the smallest number we can get away with?

00:04:22.160 --> 00:04:24.160
Now, these are big questions in computer science.

00:04:24.160 --> 00:04:26.160
These are all complexity questions,

00:04:26.160 --> 00:04:28.160
and computer science tells us that these are very hard questions.

00:04:28.160 --> 00:04:30.160
Almost -- many of them are impossible.

00:04:30.160 --> 00:04:33.160
But for some tasks, we can start to answer them.

00:04:33.160 --> 00:04:34.160
So, I'm going to start asking those questions

00:04:34.160 --> 00:04:37.160
for the DNA structures I'm going to talk about next.

00:04:37.160 --> 00:04:40.160
So, this is normal DNA, what you think of as normal DNA.

00:04:40.160 --> 00:04:42.160
It's double-stranded, it's a double helix,

00:04:42.160 --> 00:04:45.160
has the As, Ts, Cs and Gs that pair to hold the strands together.

00:04:45.160 --> 00:04:47.160
And I'm going to draw it like this sometimes,

00:04:47.160 --> 00:04:49.160
just so I don't scare you.

00:04:49.160 --> 00:04:52.160
We want to look at individual strands and not think about the double helix.

00:04:52.160 --> 00:04:55.160
When we synthesize it, it comes single-stranded,

00:04:55.160 --> 00:04:58.160
so we can take the blue strand in one tube

00:04:58.160 --> 00:05:00.160
and make an orange strand in the other tube,

00:05:00.160 --> 00:05:02.160
and they're floppy when they're single-stranded.

00:05:02.160 --> 00:05:05.160
You mix them together and they make a rigid double helix.

00:05:05.160 --> 00:05:07.160
Now for the last 25 years,

00:05:07.160 --> 00:05:09.160
Ned Seeman and a bunch of his descendants

00:05:09.160 --> 00:05:12.160
have worked very hard and made beautiful three-dimensional structures

00:05:12.160 --> 00:05:15.160
using this kind of reaction of DNA strands coming together.

00:05:15.160 --> 00:05:18.160
But a lot of their approaches, though elegant, take a long time.

00:05:18.160 --> 00:05:21.160
They can take a couple of years, or it can be difficult to design.

00:05:21.160 --> 00:05:24.160
So I came up with a new method a couple of years ago

00:05:24.160 --> 00:05:25.160
I call DNA origami

00:05:25.160 --> 00:05:27.160
that's so easy you could do it at home in your kitchen

00:05:27.160 --> 00:05:29.160
and design the stuff on a laptop.

00:05:29.160 --> 00:05:32.160
But to do it, you need a long, single strand of DNA,

00:05:32.160 --> 00:05:34.160
which is technically very difficult to get.

00:05:34.160 --> 00:05:36.160
So, you can go to a natural source.

00:05:36.160 --> 00:05:38.160
You can look in this computer-fabricated artifact,

00:05:38.160 --> 00:05:40.160
and he's got a double-stranded genome -- that's no good.

00:05:40.160 --> 00:05:43.160
You look in his intestines. There are billions of bacteria.

00:05:43.160 --> 00:05:45.160
They're no good either.

00:05:45.160 --> 00:05:47.160
Double strand again, but inside them, they're infected with a virus

00:05:47.160 --> 00:05:50.160
that has a nice, long, single-stranded genome

00:05:50.160 --> 00:05:52.160
that we can fold like a piece of paper.

00:05:52.160 --> 00:05:53.160
And here's how we do it.

00:05:53.160 --> 00:05:54.160
This is part of that genome.

00:05:54.160 --> 00:05:57.160
We add a bunch of short, synthetic DNAs that I call staples.

00:05:57.160 --> 00:06:01.160
Each one has a left half that binds the long strand in one place,

00:06:01.160 --> 00:06:04.160
and a right half that binds it in a different place,

00:06:04.160 --> 00:06:06.160
and brings the long strand together like this.

00:06:07.160 --> 00:06:09.160
The net action of many of these on that long strand

00:06:09.160 --> 00:06:11.160
is to fold it into something like a rectangle.

00:06:11.160 --> 00:06:13.160
Now, we can't actually take a movie of this process,

00:06:13.160 --> 00:06:15.160
but Shawn Douglas at Harvard

00:06:15.160 --> 00:06:17.160
has made a nice visualization for us

00:06:17.160 --> 00:06:21.160
that begins with a long strand and has some short strands in it.

00:06:21.160 --> 00:06:25.160
And what happens is that we mix these strands together.

00:06:25.160 --> 00:06:27.160
We heat them up, we add a little bit of salt,

00:06:27.160 --> 00:06:29.160
we heat them up to almost boiling and cool them down,

00:06:29.160 --> 00:06:30.160
and as we cool them down,

00:06:30.160 --> 00:06:32.160
the short strands bind the long strands

00:06:32.160 --> 00:06:34.160
and start to form structure.

00:06:34.160 --> 00:06:37.160
And you can see a little bit of double helix forming there.

00:06:38.160 --> 00:06:40.160
When you look at DNA origami,

00:06:40.160 --> 00:06:43.160
you can see that what it really is,

00:06:43.160 --> 00:06:44.160
even though you think it's complicated,

00:06:44.160 --> 00:06:47.160
is a bunch of double helices that are parallel to each other,

00:06:47.160 --> 00:06:49.160
and they're held together

00:06:49.160 --> 00:06:51.160
by places where short strands go along one helix

00:06:51.160 --> 00:06:53.160
and then jump to another one.

00:06:53.160 --> 00:06:56.160
So there's a strand that goes like this, goes along one helix and binds --

00:06:56.160 --> 00:06:58.160
it jumps to another helix and comes back.

00:06:58.160 --> 00:07:00.160
That holds the long strand like this.

00:07:00.160 --> 00:07:03.160
Now, to show that we could make any shape or pattern

00:07:03.160 --> 00:07:05.160
that we wanted, I tried to make this shape.

00:07:06.160 --> 00:07:08.160
I wanted to fold DNA into something that goes up over the eye,

00:07:08.160 --> 00:07:11.160
down the nose, up the nose, around the forehead,

00:07:11.160 --> 00:07:14.160
back down and end in a little loop like this.

00:07:14.160 --> 00:07:17.160
And so, I thought, if this could work, anything could work.

00:07:17.160 --> 00:07:20.160
So I had the computer program design the short staples to do this.

00:07:20.160 --> 00:07:22.160
I ordered them; they came by FedEx.

00:07:22.160 --> 00:07:24.160
I mixed them up, heated them, cooled them down,

00:07:24.160 --> 00:07:28.160
and I got 50 billion little smiley faces

00:07:28.160 --> 00:07:30.160
floating around in a single drop of water.

00:07:30.160 --> 00:07:32.160
And each one of these is just

00:07:32.160 --> 00:07:36.160
one-thousandth the width of a human hair, OK?

00:07:36.160 --> 00:07:39.160
So, they're all floating around in solution, and to look at them,

00:07:39.160 --> 00:07:41.160
you have to get them on a surface where they stick.

00:07:41.160 --> 00:07:43.160
So, you pour them out onto a surface

00:07:43.160 --> 00:07:45.160
and they start to stick to that surface,

00:07:45.160 --> 00:07:47.160
and we take a picture using an atomic-force microscope.

00:07:47.160 --> 00:07:49.160
It's got a needle, like a record needle,

00:07:49.160 --> 00:07:51.160
that goes back and forth over the surface,

00:07:51.160 --> 00:07:54.160
bumps up and down, and feels the height of the first surface.

00:07:54.160 --> 00:07:56.160
It feels the DNA origami.

00:07:56.160 --> 00:07:58.160
There's the atomic-force microscope working

00:07:59.160 --> 00:08:00.160
and you can see that the landing's a little rough.

00:08:00.160 --> 00:08:02.160
When you zoom in, they've got, you know,

00:08:02.160 --> 00:08:03.160
weak jaws that flip over their heads

00:08:03.160 --> 00:08:06.160
and some of their noses get punched out, but it's pretty good.

00:08:06.160 --> 00:08:08.160
You can zoom in and even see the extra little loop,

00:08:08.160 --> 00:08:10.160
this little nano-goatee.

00:08:10.160 --> 00:08:13.160
Now, what's great about this is anybody can do this.

00:08:13.160 --> 00:08:17.160
And so, I got this in the mail about a year after I did this, unsolicited.

00:08:17.160 --> 00:08:20.160
Anyone know what this is? What is it?

00:08:20.160 --> 00:08:22.160
It's China, right?

00:08:22.160 --> 00:08:24.160
So, what happened is, a graduate student in China,

00:08:24.160 --> 00:08:26.160
Lulu Qian, did a great job.

00:08:26.160 --> 00:08:28.160
She wrote all her own software

00:08:28.160 --> 00:08:30.160
to design and built this DNA origami,

00:08:30.160 --> 00:08:33.160
a beautiful rendition of China, which even has Taiwan,

00:08:33.160 --> 00:08:36.160
and you can see it's sort of on the world's shortest leash, right?

00:08:36.160 --> 00:08:38.160
(Laughter)

00:08:39.160 --> 00:08:40.160
So, this works really well

00:08:41.160 --> 00:08:43.160
and you can make patterns as well as shapes, OK?

00:08:44.160 --> 00:08:47.160
And you can make a map of the Americas and spell DNA with DNA.

00:08:47.160 --> 00:08:50.160
And what's really neat about it --

00:08:50.160 --> 00:08:52.160
well, actually, this all looks like nano-artwork,

00:08:52.160 --> 00:08:53.160
but it turns out that nano-artwork

00:08:53.160 --> 00:08:55.160
is just what you need to make nano-circuits.

00:08:55.160 --> 00:08:57.160
So, you can put circuit components on the staples,

00:08:57.160 --> 00:08:59.160
like a light bulb and a light switch.

00:08:59.160 --> 00:09:02.160
Let the thing assemble, and you'll get some kind of a circuit.

00:09:02.160 --> 00:09:05.160
And then you can maybe wash the DNA away and have the circuit left over.

00:09:05.160 --> 00:09:07.160
So, this is what some colleagues of mine at Caltech did.

00:09:07.160 --> 00:09:10.160
They took a DNA origami, organized some carbon nano-tubes,

00:09:10.160 --> 00:09:12.160
made a little switch, you see here, wired it up,

00:09:12.160 --> 00:09:15.160
tested it and showed that it is indeed a switch.

00:09:15.160 --> 00:09:17.160
Now, this is just a single switch

00:09:17.160 --> 00:09:21.160
and you need half a billion for a computer, so we have a long way to go.

00:09:21.160 --> 00:09:23.160
But this is very promising

00:09:23.160 --> 00:09:28.160
because the origami can organize parts just one-tenth the size

00:09:28.160 --> 00:09:29.160
of those in a normal computer.

00:09:29.160 --> 00:09:32.160
So it's very promising for making small computers.

00:09:32.160 --> 00:09:35.160
Now, I want to get back to that compiler.

00:09:35.160 --> 00:09:38.160
The DNA origami is a proof that that compiler actually works.

00:09:39.160 --> 00:09:41.160
So, you start with something in the computer.

00:09:41.160 --> 00:09:44.160
You get a high-level description of the computer program,

00:09:44.160 --> 00:09:46.160
a high-level description of the origami.

00:09:46.160 --> 00:09:49.160
You can compile it to molecules, send it to a synthesizer,

00:09:49.160 --> 00:09:50.160
and it actually works.

00:09:50.160 --> 00:09:54.160
And it turns out that a company has made a nice program

00:09:54.160 --> 00:09:56.160
that's much better than my code, which was kind of ugly,

00:09:56.160 --> 00:09:57.160
and will allow us to do this in a nice,

00:09:57.160 --> 00:09:59.160
visual, computer-aided design way.

00:10:00.160 --> 00:10:01.160
So, now you can say, all right,

00:10:01.160 --> 00:10:03.160
why isn't DNA origami the end of the story?

00:10:03.160 --> 00:10:05.160
You have your molecular compiler, you can do whatever you want.

00:10:05.160 --> 00:10:08.160
The fact is that it does not scale.

00:10:08.160 --> 00:10:11.160
So if you want to build a human from DNA origami,

00:10:11.160 --> 00:10:13.160
the problem is, you need a long strand

00:10:13.160 --> 00:10:16.160
that's 10 trillion trillion bases long.

00:10:16.160 --> 00:10:18.160
That's three light years' worth of DNA,

00:10:18.160 --> 00:10:20.160
so we're not going to do this.

00:10:20.160 --> 00:10:22.160
We're going to turn to another technology,

00:10:22.160 --> 00:10:24.160
called algorithmic self-assembly of tiles.

00:10:24.160 --> 00:10:26.160
It was started by Erik Winfree,

00:10:26.160 --> 00:10:27.160
and what it does,

00:10:27.160 --> 00:10:31.160
it has tiles that are a hundredth the size of a DNA origami.

00:10:31.160 --> 00:10:33.160
You zoom in, there are just four DNA strands

00:10:34.160 --> 00:10:36.160
and they have little single-stranded bits on them

00:10:36.160 --> 00:10:38.160
that can bind to other tiles, if they match.

00:10:38.160 --> 00:10:41.160
And we like to draw these tiles as little squares.

00:10:42.160 --> 00:10:44.160
And if you look at their sticky ends, these little DNA bits,

00:10:44.160 --> 00:10:47.160
you can see that they actually form a checkerboard pattern.

00:10:47.160 --> 00:10:50.160
So, these tiles would make a complicated, self-assembling checkerboard.

00:10:50.160 --> 00:10:52.160
And the point of this, if you didn't catch that,

00:10:52.160 --> 00:10:55.160
is that tiles are a kind of molecular program

00:10:55.160 --> 00:10:58.160
and they can output patterns.

00:10:58.160 --> 00:11:00.160
And a really amazing part of this is

00:11:00.160 --> 00:11:02.160
that any computer program can be translated

00:11:02.160 --> 00:11:05.160
into one of these tile programs -- specifically, counting.

00:11:05.160 --> 00:11:08.160
So, you can come up with a set of tiles

00:11:08.160 --> 00:11:11.160
that when they come together, form a little binary counter

00:11:11.160 --> 00:11:13.160
rather than a checkerboard.

00:11:13.160 --> 00:11:16.160
So you can read off binary numbers five, six and seven.

00:11:16.160 --> 00:11:19.160
And in order to get these kinds of computations started right,

00:11:19.160 --> 00:11:21.160
you need some kind of input, a kind of seed.

00:11:21.160 --> 00:11:23.160
You can use DNA origami for that.

00:11:23.160 --> 00:11:25.160
You can encode the number 32

00:11:25.160 --> 00:11:27.160
in the right-hand side of a DNA origami,

00:11:27.160 --> 00:11:29.160
and when you add those tiles that count,

00:11:29.160 --> 00:11:32.160
they will start to count -- they will read that 32

00:11:32.160 --> 00:11:34.160
and they'll stop at 32.

00:11:34.160 --> 00:11:37.160
So, what we've done is we've figured out a way

00:11:37.160 --> 00:11:40.160
to have a molecular program know when to stop going.

00:11:40.160 --> 00:11:42.160
It knows when to stop growing because it can count.

00:11:42.160 --> 00:11:44.160
It knows how big it is.

00:11:44.160 --> 00:11:47.160
So, that answers that sort of first question I was talking about.

00:11:47.160 --> 00:11:50.160
It doesn't tell us how babies do it, however.

00:11:50.160 --> 00:11:54.160
So now, we can use this counting to try and get at much bigger things

00:11:54.160 --> 00:11:55.160
than DNA origami could otherwise.

00:11:55.160 --> 00:11:58.160
Here's the DNA origami, and what we can do

00:11:58.160 --> 00:12:01.160
is we can write 32 on both edges of the DNA origami,

00:12:01.160 --> 00:12:03.160
and we can now use our watering can

00:12:03.160 --> 00:12:07.160
and water with tiles, and we can start growing tiles off of that

00:12:07.160 --> 00:12:09.160
and create a square.

00:12:09.160 --> 00:12:12.160
The counter serves as a template

00:12:12.160 --> 00:12:14.160
to fill in a square in the middle of this thing.

00:12:14.160 --> 00:12:15.160
So, what we've done is we've succeeded

00:12:15.160 --> 00:12:18.160
in making something much bigger than a DNA origami

00:12:18.160 --> 00:12:21.160
by combining DNA origami with tiles.

00:12:21.160 --> 00:12:24.160
And the neat thing about it is, is that it's also reprogrammable.

00:12:24.160 --> 00:12:28.160
You can just change a couple of the DNA strands in this binary representation

00:12:28.160 --> 00:12:31.160
and you'll get 96 rather than 32.

00:12:31.160 --> 00:12:34.160
And if you do that, the origami's the same size,

00:12:34.160 --> 00:12:38.160
but the resulting square that you get is three times bigger.

00:12:39.160 --> 00:12:40.160
So, this sort of recapitulates

00:12:40.160 --> 00:12:42.160
what I was telling you about development.

00:12:42.160 --> 00:12:45.160
You have a very sensitive computer program

00:12:45.160 --> 00:12:48.160
where small changes -- single, tiny, little mutations --

00:12:48.160 --> 00:12:50.160
can take something that made one size square

00:12:50.160 --> 00:12:53.160
and make something very much bigger.

00:12:54.160 --> 00:12:57.160
Now, this -- using counting to compute

00:12:57.160 --> 00:12:59.160
and build these kinds of things

00:12:59.160 --> 00:13:01.160
by this kind of developmental process

00:13:01.160 --> 00:13:05.160
is something that also has bearing on Craig Venter's question.

00:13:05.160 --> 00:13:07.160
So, you can ask, how many DNA strands are required

00:13:07.160 --> 00:13:09.160
to build a square of a given size?

00:13:09.160 --> 00:13:14.160
If we wanted to make a square of size 10, 100 or 1,000,

00:13:14.160 --> 00:13:16.160
if we used DNA origami alone,

00:13:16.160 --> 00:13:19.160
we would require a number of DNA strands that's the square

00:13:19.160 --> 00:13:21.160
of the size of that square;

00:13:21.160 --> 00:13:23.160
so we'd need 100, 10,000 or a million DNA strands.

00:13:23.160 --> 00:13:25.160
That's really not affordable.

00:13:25.160 --> 00:13:27.160
But if we use a little computation --

00:13:27.160 --> 00:13:31.160
we use origami, plus some tiles that count --

00:13:31.160 --> 00:13:34.160
then we can get away with using 100, 200 or 300 DNA strands.

00:13:34.160 --> 00:13:39.160
And so we can exponentially reduce the number of DNA strands we use,

00:13:39.160 --> 00:13:42.160
if we use counting, if we use a little bit of computation.

00:13:42.160 --> 00:13:45.160
And so computation is some very powerful way

00:13:45.160 --> 00:13:48.160
to reduce the number of molecules you need to build something,

00:13:48.160 --> 00:13:51.160
to reduce the size of the genome that you're building.

00:13:51.160 --> 00:13:54.160
And finally, I'm going to get back to that sort of crazy idea

00:13:54.160 --> 00:13:56.160
about computers building computers.

00:13:56.160 --> 00:13:59.160
If you look at the square that you build with the origami

00:13:59.160 --> 00:14:01.160
and some counters growing off it,

00:14:01.160 --> 00:14:04.160
the pattern that it has is exactly the pattern that you need

00:14:04.160 --> 00:14:05.160
to make a memory.

00:14:05.160 --> 00:14:08.160
So if you affix some wires and switches to those tiles --

00:14:08.160 --> 00:14:11.160
rather than to the staple strands, you affix them to the tiles --

00:14:11.160 --> 00:14:14.160
then they'll self-assemble the somewhat complicated circuits,

00:14:14.160 --> 00:14:17.160
the demultiplexer circuits, that you need to address this memory.

00:14:17.160 --> 00:14:19.160
So you can actually make a complicated circuit

00:14:19.160 --> 00:14:21.160
using a little bit of computation.

00:14:21.160 --> 00:14:24.160
It's a molecular computer building an electronic computer.

00:14:24.160 --> 00:14:27.160
Now, you ask me, how far have we gotten down this path?

00:14:27.160 --> 00:14:30.160
Experimentally, this is what we've done in the last year.

00:14:30.160 --> 00:14:32.160
Here is a DNA origami rectangle,

00:14:33.160 --> 00:14:35.160
and here are some tiles growing from it.

00:14:35.160 --> 00:14:37.160
And you can see how they count.

00:14:37.160 --> 00:14:49.160
One, two, three, four, five, six, nine, 10, 11, 12, 17.

00:14:49.160 --> 00:14:53.160
So it's got some errors, but at least it counts up.

00:14:53.160 --> 00:14:54.160
(Laughter)

00:14:54.160 --> 00:14:57.160
So, it turns out we actually had this idea nine years ago,

00:14:57.160 --> 00:15:00.160
and that's about the time constant for how long it takes

00:15:00.160 --> 00:15:02.160
to do these kinds of things, so I think we made a lot of progress.

00:15:02.160 --> 00:15:04.160
We've got ideas about how to fix these errors.

00:15:04.160 --> 00:15:06.160
And I think in the next five or 10 years,

00:15:06.160 --> 00:15:08.160
we'll make the kind of squares that I described

00:15:08.160 --> 00:15:11.160
and maybe even get to some of those self-assembled circuits.

00:15:11.160 --> 00:15:15.160
So now, what do I want you to take away from this talk?

00:15:15.160 --> 00:15:17.160
I want you to remember that

00:15:17.160 --> 00:15:21.160
to create life's very diverse and complex forms,

00:15:21.160 --> 00:15:23.160
life uses computation to do that.

00:15:23.160 --> 00:15:27.160
And the computations that it uses, they're molecular computations,

00:15:27.160 --> 00:15:29.160
and in order to understand this and get a better handle on it,

00:15:29.160 --> 00:15:31.160
as Feynman said, you know,

00:15:31.160 --> 00:15:33.160
we need to build something to understand it.

00:15:33.160 --> 00:15:37.160
And so we are going to use molecules and refashion this thing,

00:15:37.160 --> 00:15:39.160
rebuild everything from the bottom up,

00:15:39.160 --> 00:15:42.160
using DNA in ways that nature never intended,

00:15:42.160 --> 00:15:44.160
using DNA origami,

00:15:44.160 --> 00:15:47.160
and DNA origami to seed this algorithmic self-assembly.

00:15:47.160 --> 00:15:49.160
You know, so this is all very cool,

00:15:50.160 --> 00:15:51.160
but what I'd like you to take from the talk,

00:15:51.160 --> 00:15:53.160
hopefully from some of those big questions,

00:15:53.160 --> 00:15:56.160
is that this molecular programming isn't just about making gadgets.

00:15:56.160 --> 00:15:58.160
It's not just making about --

00:15:58.160 --> 00:16:00.160
it's making self-assembled cell phones and circuits.

00:16:00.160 --> 00:16:02.160
What it's really about is taking computer science

00:16:02.160 --> 00:16:05.160
and looking at big questions in a new light,

00:16:05.160 --> 00:16:07.160
asking new versions of those big questions

00:16:07.160 --> 00:16:09.160
and trying to understand how biology

00:16:09.160 --> 00:16:11.160
can make such amazing things. Thank you.

00:16:12.160 --> 00:16:19.160
(Applause)

