WEBVTT
Kind: captions
Language: vi

00:00:00.000 --> 00:00:07.000
Translator: Uyên Võ
Reviewer: Thao Phan

00:00:11.820 --> 00:00:14.820
Con người tranh luận sôi nổi về
định nghĩa của sự sống.

00:00:14.820 --> 00:00:19.820
Họ hỏi liệu định nghĩa đó gồm quá trình
sinh sản, sự trao đổi chất hay tiến hoá.

00:00:19.820 --> 00:00:21.820
Và tôi không biết câu trả lời cho
câu hỏi đó, nên tôi sẽ không trả lời bạn.

00:00:21.820 --> 00:00:24.820
Tôi sẽ nói rằng sự sống liên quan
đến việc lập trình.

00:00:24.820 --> 00:00:26.820
Đây là một chương trình máy tính.

00:00:26.820 --> 00:00:29.820
Khởi động từ một tế bào,
chương trình sẽ chạy,

00:00:29.820 --> 00:00:32.820
và cho kết quả là con người này;

00:00:32.820 --> 00:00:35.820
hay với một sự thay đổi nhỏ,
kết quả sẽ là người này;

00:00:35.820 --> 00:00:37.820
hay với thay đổi nhỏ khác, là người này;

00:00:37.820 --> 00:00:40.820
hay với thay đổi lớn hơn,
tạo ra con chó này,

00:00:40.820 --> 00:00:42.820
hay cái cây này, hoặc con cá voi này.

00:00:42.820 --> 00:00:44.820
Vậy nên giờ, nếu bạn ví von bộ gen

00:00:44.820 --> 00:00:46.820
thực sự là một chương trình,

00:00:46.820 --> 00:00:48.820
bạn sẽ xem Chris Anderson

00:00:48.820 --> 00:00:51.820
là kết quả của chương trình máy tính,
cũng như Jim Watson,

00:00:51.820 --> 00:00:54.820
Craig Venter, cũng như tất cả chúng ta.

00:00:54.820 --> 00:00:56.820
Và khi tự thuyết phục bản thân rằng
phép ví von này đúng,

00:00:56.820 --> 00:00:58.820
thì bạn sẽ thấy có nhiều
nét tương đồng giữa

00:00:58.820 --> 00:01:01.820
chương trình di truyền
và chương trình máy tính.

00:01:01.820 --> 00:01:03.820
Nhưng theo tôi, điều quan trọng nhất

00:01:03.820 --> 00:01:06.820
là mức độ nhạy cảm với các thay đổi nhỏ

00:01:06.820 --> 00:01:09.820
có thể dẫn đến thay đổi lớn trong 
quá trình phát triển sinh học - đầu ra.

00:01:09.820 --> 00:01:11.820
Một đột biến nhỏ 
có thể biến con ruồi hai cánh

00:01:11.820 --> 00:01:12.820
thành bốn cánh.

00:01:12.820 --> 00:01:16.820
Hoặc nó sẽ biến râu con ruồi thành chân.

00:01:16.820 --> 00:01:18.820
Hoặc như trong phim "Cô dâu công chúa,"

00:01:18.820 --> 00:01:20.820
nó có thể tạo ra người có sáu ngón tay.

00:01:20.820 --> 00:01:22.820
Điểm mốc của các chương trình máy tính

00:01:22.820 --> 00:01:25.820
chỉ là sự nhạy cảm với những thay đổi nhỏ.

00:01:25.820 --> 00:01:27.820
Giả sử tài khoản ngân hàng của bạn là
1 đô, và bạn thay đổi một dấu chấm,

00:01:27.820 --> 00:01:29.820
bạn có thể có một nghìn đô.

00:01:29.820 --> 00:01:32.820
Vậy nên những thay đổi nhỏ này
là thứ mà tôi nghĩ rằng

00:01:32.820 --> 00:01:34.820
chúng chỉ ra một sự tính toán phức tạp

00:01:34.820 --> 00:01:38.820
trong quá trình phát triển nằm dưới những thay đổi lớn.

00:01:38.820 --> 00:01:44.820
Vậy nên, tất cả điều này chỉ ra có những
chương trình phân tử nằm dưới sinh vật học

00:01:44.820 --> 00:01:48.820
và nó cho ta thấy sức mạnh của
các lập trình sinh học phân tử.

00:01:48.820 --> 00:01:50.820
Và điều tôi muốn làm là viết
các lập trình phân tử,

00:01:50.820 --> 00:01:52.820
để phát triển công nghệ

00:01:52.820 --> 00:01:53.820
Và có rất nhiều người đang làm điều này,

00:01:53.820 --> 00:01:56.820
rất nhiều nhà sinh học tổng hợp,
như Craig Venter.

00:01:56.820 --> 00:01:58.820
Và họ tập trung vào việc sử dụng tế bào.

00:01:58.820 --> 00:02:00.820
Họ định hướng tế bào.

00:02:00.820 --> 00:02:02.820
Vì vậy các bạn tôi,
những nhà lập trình phân tử, và tôi

00:02:02.820 --> 00:02:04.820
tiếp cận theo hướng
sinh học phân tử

00:02:04.820 --> 00:02:07.820
Chúng tôi quan tâm đến việc sử dụng 
DNA, RNA và protein,

00:02:07.820 --> 00:02:10.820
và tạo ra ngôn ngữ mới cho việc 
xây dựng những điều từ căn bản

00:02:10.820 --> 00:02:11.820
bằng các phân tử sinh học,

00:02:11.820 --> 00:02:14.820
hầu như không liên quan đến sinh vật học.

00:02:14.820 --> 00:02:18.820
Vì vậy, đây là tất cả bộ máy trong tế bào.

00:02:18.820 --> 00:02:20.820
Đây là một camera

00:02:20.820 --> 00:02:21.820
Bộ máy năng lượng của tế bào

00:02:21.820 --> 00:02:23.820
một vài công tắc để bật tắt gen,

00:02:23.820 --> 00:02:26.820
bộ xương tế bào, động cơ giúp bạn cử động cơ.

00:02:26.820 --> 00:02:28.820
Nhóm lập trình phân tử nhỏ của tôi

00:02:28.820 --> 00:02:32.820
đang cố tái tạo các phần này từ DNA.

00:02:32.820 --> 00:02:34.820
Chúng tôi không phải là người cuồng DNA, 
nhưng DNA là nguyên liệu rẻ nhất,

00:02:34.820 --> 00:02:37.820
dễ hiểu nhất và dễ lập trình nhất.

00:02:37.820 --> 00:02:39.820
Khi các vật liệu khác
trở nên dễ sử dụng hơn --

00:02:39.820 --> 00:02:42.820
có thể là protein --
chúng tôi sẽ thử với chúng.

00:02:42.820 --> 00:02:44.820
Nếu thành công, lập trình phân tử
sẽ trông như thế nào?

00:02:44.820 --> 00:02:46.820
Bạn sẽ ngồi trước màn hình máy tính.

00:02:46.820 --> 00:02:48.820
Bạn sẽ thiết kế thứ gì đó
như chiếc điện thoại di động,

00:02:48.820 --> 00:02:50.820
bằng một ngôn ngữ cấp cao,
bạn sẽ mô tả chiếc di động đó.

00:02:50.820 --> 00:02:52.820
Sau đó sẽ có một máy biên soạn

00:02:52.820 --> 00:02:53.820
đem những mô tả đó

00:02:53.820 --> 00:02:55.820
và biến chúng thành những phân tử thật

00:02:55.820 --> 00:02:57.820
có thể được đưa đến máy tổng hợp

00:02:57.820 --> 00:03:00.820
và máy tổng hợp sẽ đóng gói các
phân tử này vào trong hạt giống.

00:03:00.820 --> 00:03:03.820
Và chuyện gì sẽ xảy ra nếu bạn trồng
và chăm sóc hạt giống đó,

00:03:03.820 --> 00:03:05.820
liệu nó có sẽ phát triển
theo tiến trình đã tính trước

00:03:05.820 --> 00:03:08.820
một tính toán cấp phân tử, và nó sẽ tạo nên 
một máy tính điện tử.

00:03:08.820 --> 00:03:11.780
Và nếu tôi chưa nói rõ
quan điểm của mình thì,

00:03:11.820 --> 00:03:13.820
tôi cho rằng sự sống luôn là các máy tính
phân tử

00:03:13.820 --> 00:03:15.820
tạo nên các máy tính điện hoá,

00:03:15.820 --> 00:03:17.820
tạo nên các máy tính điện tử,

00:03:17.820 --> 00:03:19.820
mà sự kết hợp với máy tính điện hoá

00:03:19.820 --> 00:03:21.820
sẽ tạo nên máy tính phân tử mới,

00:03:21.820 --> 00:03:24.820
rồi sẽ tạo nên máy tính điện tử mới,
và cứ thế.

00:03:24.820 --> 00:03:25.820
Và nếu bạn tin vào điều này,

00:03:25.820 --> 00:03:27.820
và bạn nghĩ sự sống là sự lập trình,
như tôi vậy,

00:03:27.820 --> 00:03:30.820
thì bạn sẽ tiếp cận các câu hỏi lớn
bằng đôi mắt của nhà khoa học máy tính.

00:03:30.820 --> 00:03:34.820
Vậy câu hỏi lớn là làm sao để đứa trẻ 
biết khi nào nó ngừng lớn lên?

00:03:34.820 --> 00:03:36.820
Và cho lập trình phân tử,

00:03:36.820 --> 00:03:38.820
câu hỏi là làm sao để chiếc điện thoại
biết khi nào ngừng phát triển?

00:03:38.820 --> 00:03:39.820
(Cười lớn)

00:03:39.820 --> 00:03:42.820
Hay làm sao chương trình máy tính biết
khi nào ngừng chạy?

00:03:42.820 --> 00:03:45.820
Hay hơn nữa, làm sao bạn biết
liệu một chương trình có dừng lại?

00:03:45.820 --> 00:03:47.820
Còn có nhiều câu hỏi tương tự như vậy nữa.

00:03:47.820 --> 00:03:49.820
Một trong số đó
là câu hỏi của Craig Venter

00:03:49.820 --> 00:03:51.820
Tôi nghĩ ông ta thật sự là một nhà
khoa học máy tính.

00:03:51.820 --> 00:03:54.820
Ông ấy hỏi, bộ gen tối thiểu
phải lớn bao nhiêu

00:03:54.820 --> 00:03:56.820
để cho ta một vi sinh vật có chức năng?

00:03:56.820 --> 00:03:58.820
Phải sử dụng tối thiểu chừng nào gen?

00:03:58.820 --> 00:04:00.820
Câu hỏi này giống hệt như,

00:04:00.820 --> 00:04:01.820
chương trình nhỏ nhất mà tôi có thể viết

00:04:01.820 --> 00:04:03.820
để hoạt động như Microsoft Word là gì?

00:04:03.820 --> 00:04:04.820
(Cười lớn)

00:04:04.820 --> 00:04:08.820
Và khi nói ông ấy viết ra
một vi khuẩn nhỏ hơn,

00:04:08.820 --> 00:04:09.820
ông ấy đang viết bộ gen
có thể hoạt động được,

00:04:09.820 --> 00:04:11.820
chúng ta có thể viết
các chương trình nhỏ hơn

00:04:11.820 --> 00:04:13.820
mà hoạt động được như Microsoft Word.

00:04:13.820 --> 00:04:15.820
Nhưng với lập trình phân tử, câu hỏi là,

00:04:15.820 --> 00:04:19.820
có bao nhiêu phân tử cần đưa vào hạt giống
để tạo ra một chiếc điện thoại?

00:04:19.820 --> 00:04:21.820
Con số nhỏ nhất là bao nhiêu?

00:04:21.820 --> 00:04:23.820
Hiện tại đây chính là những câu hỏi lớn
với khoa học máy tính.

00:04:23.820 --> 00:04:25.820
Đây là những câu hỏi phức tạp,

00:04:25.820 --> 00:04:27.820
và khoa học máy tính cho thấy chúng
là những câu hỏi khó.

00:04:27.820 --> 00:04:29.820
Hầu như - nhiều câu hỏi là bất khả thi.

00:04:29.820 --> 00:04:32.820
Nhưng với một số, chúng ta có thể bắt đầu
tìm ra câu trả lời.

00:04:32.820 --> 00:04:33.820
Vậy nên tôi sẽ bắt đầu hỏi những câu hỏi

00:04:33.820 --> 00:04:36.820
cho cấu trúc DNA mà tôi sắp nói tới.

00:04:36.820 --> 00:04:39.820
Vậy, đây là một DNA bình thường
mà bạn biết đến.

00:04:39.820 --> 00:04:41.820
Nó có hai chuỗi xoắn với nhau,

00:04:41.820 --> 00:04:44.820
và có các A, T, C, G bắt đôi để nối
hai chuỗi với nhau.

00:04:44.820 --> 00:04:46.820
Và tôi sẽ vẽ như thế này,

00:04:46.820 --> 00:04:48.820
để không khiến bạn cảm thấy kì lạ.

00:04:48.820 --> 00:04:51.820
Ta quan tâm đến từng chuỗi riêng biệt 
thay vì hai chuỗi xoắn.

00:04:51.820 --> 00:04:54.820
Khi ta tổng hợp, kết quả chỉ là một chuỗi,

00:04:54.820 --> 00:04:57.820
và chúng ta có thể lấy chuỗi xanh dương
trong một ống

00:04:57.820 --> 00:04:59.820
và tạo ra chuỗi cam ở ống khác,

00:04:59.820 --> 00:05:01.820
và chúng uốn éo khi ở dạng đơn chuỗi.

00:05:01.820 --> 00:05:04.820
Khi bạn trộn chúng lại, chúng sẽ tạo nên
cấu trúc hai chuỗi xoắn.

00:05:04.820 --> 00:05:06.820
Trong vòng 25 năm gần đây,

00:05:06.820 --> 00:05:08.820
Ned Seeman và nhiều hậu duệ của ông

00:05:08.820 --> 00:05:11.820
đã làm việc cật lực và
tạo ra cấu trúc 3D xinh đẹp này

00:05:11.820 --> 00:05:14.820
bằng phản ứng của các chuỗi DNA
ghép lại với nhau.

00:05:14.820 --> 00:05:17.820
Nhưng phần lớn các phương pháp đó
dù tinh tế, cũng mất nhiều thời gian.

00:05:17.820 --> 00:05:20.820
Chúng mất vài năm,
hoặc rất khó để thiết kế.

00:05:20.820 --> 00:05:23.820
Nên vài năm trước tôi đã tìm ra
một phương pháp mới

00:05:23.820 --> 00:05:24.820
gọi là DNA origami

00:05:24.820 --> 00:05:26.820
dễ dàng đến mức bạn có thể thực hiện
ngay tại bếp nhà bạn

00:05:26.820 --> 00:05:28.820
và thiết kế món đồ từ máy tính xách tay.

00:05:28.820 --> 00:05:31.820
Nhưng để làm điều đó,
bạn cần một chuỗi DNA đơn dài,

00:05:31.820 --> 00:05:33.820
và thực tế rất khó để có được nó.

00:05:33.820 --> 00:05:35.820
Do đó, bạn có thể tìm trong tự nhiên.

00:05:35.820 --> 00:05:37.820
Bạn có thể nhìn vào vật thể tạo thành từ
máy tính này,

00:05:37.820 --> 00:05:39.820
người này có hệ gen với DNA đôi -- không tốt.

00:05:39.820 --> 00:05:42.820
Bạn tìm trong ruột. Có hàng tỉ vi khuẩn.

00:05:42.820 --> 00:05:44.820
Cũng không tốt.

00:05:44.820 --> 00:05:46.820
Cũng chuỗi đôi,
nhưng bên trong, chúng bị nhiễm virus

00:05:46.820 --> 00:05:49.820
có bộ gen với một chuỗi đơn, dài, đẹp

00:05:49.820 --> 00:05:51.820
mà chúng ta có thể xếp như một mảnh giấy.

00:05:51.820 --> 00:05:52.820
Và đây là cách chúng tôi làm.

00:05:52.820 --> 00:05:53.820
Đây là một phần của bộ gen.

00:05:53.820 --> 00:05:56.820
Chúng tôi thêm một số đoạn DNA ngắn
tổng hợp mà tôi gọi là kim dập.

00:05:56.820 --> 00:06:00.820
Mỗi DNA ngắn có một nửa bên trái gắn với 
sợi dài ở một đầu phía bên kia,

00:06:00.820 --> 00:06:03.820
và nửa bên phải gắn với một đầu khác,

00:06:03.820 --> 00:06:05.820
và nối chuỗi dài lại như thế này.

00:06:06.820 --> 00:06:08.820
Kết quả của chuỗi hoạt động
của nhiều phân tử này trên chuỗi dài

00:06:08.820 --> 00:06:10.820
là để cuộn nó lại thành hình chữ nhật.

00:06:10.820 --> 00:06:12.820
Chúng tôi thật sự không thể
quay phim lại quá trình này

00:06:12.820 --> 00:06:14.820
nhưng Shawn Douglas tại đại học Harvard

00:06:14.820 --> 00:06:16.820
đã làm cho chúng ta một mô hình

00:06:16.820 --> 00:06:20.820
bắt đầu bằng chuối dài và 
một vài chuỗi ngắn trên đó.

00:06:20.820 --> 00:06:24.820
Và những gì xảy ra khi chúng ta 
trộn những chuỗi đó lại với nhau.

00:06:24.820 --> 00:06:26.820
Chúng ta đun chúng lên, thêm một ít muối,

00:06:26.820 --> 00:06:28.820
chúng ta đun lên gần tới nhiệt độ sôi
rồi làm nguội chúng.

00:06:28.820 --> 00:06:29.820
và trong quá trình làm nguội,

00:06:29.820 --> 00:06:31.820
chuỗi ngắn gắn vào chuỗi dài

00:06:31.820 --> 00:06:33.820
và bắt đầu hình thành cấu trúc.

00:06:33.820 --> 00:06:36.820
Bạn có thể thấy một ít chuỗi xoắn kép
hình thành ở đây.

00:06:37.820 --> 00:06:39.820
Khi bạn nhìn vào DNA origami,

00:06:39.820 --> 00:06:42.820
bạn có thể thấy nó thực chất là gì,

00:06:42.820 --> 00:06:43.820
mặc dù bạn nghĩ nó phức tạp,

00:06:43.820 --> 00:06:46.820
nhưng nó chính là một nhúm các hình xoắn ốc
xếp song song với nhau

00:06:46.820 --> 00:06:48.820
và chúng giữ lấy nhau

00:06:48.820 --> 00:06:50.820
tại vị trí các chuỗi ngắn
chạy dọc chuỗi xoắn

00:06:50.820 --> 00:06:52.820
và sau đó nhảy qua chuỗi khác.

00:06:52.820 --> 00:06:55.820
Vì vậy có một chuỗi đi như thế này,
chạy dọc và nối một chuỗi xoắn

00:06:55.820 --> 00:06:57.820
nó nhảy qua chuỗi kép còn lại
và quay trở lại.

00:06:57.820 --> 00:06:59.820
Giữ cho chuối dài như thế này.

00:06:59.820 --> 00:07:02.820
Bây giờ, để cho các bạn thấy tôi có thể
làm ra được bất kì hình dạng gì

00:07:02.820 --> 00:07:04.820
chúng ta muốn, tôi sẽ làm hình này

00:07:05.820 --> 00:07:07.820
Tôi muốn cuộn DNA thành một hình
chạy lên trên con mắt,

00:07:07.820 --> 00:07:10.820
dưới cái mũi, trên cái mũi,
vòng quanh trán,

00:07:10.820 --> 00:07:13.820
vòng xuống và kết thúc bằng cái vòng nhỏ
như thế này.

00:07:13.820 --> 00:07:16.820
Vì lẽ đó, tôi nghĩ, nếu cái này làm được
thì bất cứ cái gì cũng làm được.

00:07:16.820 --> 00:07:19.820
Tôi cho máy tính thiết kế các kim dập ngắn
để làm điều này.

00:07:19.820 --> 00:07:21.820
Tôi đặt hàng, FedEx gửi cho tôi.

00:07:21.820 --> 00:07:23.820
Tôi trộn chúng lại, đun lên rồi để nguội

00:07:23.820 --> 00:07:27.820
và tôi có 50 tỉ hình mặt cười nhỏ xíu

00:07:27.820 --> 00:07:29.820
lơ lửng trong một giọt nước.

00:07:29.820 --> 00:07:31.820
Và một trong số chúng chỉ bằng

00:07:31.820 --> 00:07:35.820
1/1000 bề rộng của một sợi tóc con người.

00:07:35.820 --> 00:07:38.820
Vậy, chúng trôi lơ lửng trong dung dịch,
và để xem được chúng,

00:07:38.820 --> 00:07:40.820
bạn phải làm cho nó nổi lên bề mặt
và kết chùm lại.

00:07:40.820 --> 00:07:42.820
Nên bạn đổ chúng ra trên bề mặt phẳng

00:07:42.820 --> 00:07:44.820
và chúng bắt đầu kết dính lại
trên bề mặt đó,

00:07:44.820 --> 00:07:46.820
rồi chúng ta chụp ảnh chúng bằng
kính hiển vi lực nguyên tử.

00:07:46.820 --> 00:07:48.820
Nó có một cây kim, như cây kim ghi chú,

00:07:48.820 --> 00:07:50.820
chạy qua lại bề mặt đó,

00:07:50.820 --> 00:07:53.820
di chuyển lên xuống để cảm nhận
độ cao của bề mặt đầu tiên.

00:07:53.820 --> 00:07:55.820
Nó cảm nhận DNA origami.

00:07:55.820 --> 00:07:57.820
Có một kính hiển vi điện tử làm việc

00:07:58.820 --> 00:07:59.820
và bạn có thể thấy
bề mặt của chúng hơi gồ ghề.

00:07:59.820 --> 00:08:01.820
Khi bạn phóng to lên,

00:08:01.820 --> 00:08:02.820
chúng có vài hàm yếu vắt qua đầu chúng,

00:08:02.820 --> 00:08:05.820
và một vài cái mũi bị vỡ ra,
nhưng nhìn chung đều rất tốt.

00:08:05.820 --> 00:08:07.820
Bạn có thể phóng to
và nhìn được cái vòng nhỏ đó,

00:08:07.820 --> 00:08:09.820
cái chòm râu dê siêu nhỏ này.

00:08:09.820 --> 00:08:12.820
Bây giờ, điều tuyệt vời là
ai cũng có thể làm được việc này.

00:08:12.820 --> 00:08:16.820
Vậy nên, tôi nhận được cái này qua thư một năm
sau khi tôi làm ra nó, không hứng thú cho lắm.

00:08:16.820 --> 00:08:19.820
Có ai biết cái này là gì không?
Nó là gì?

00:08:19.820 --> 00:08:21.820
Trung Quốc phải không?

00:08:21.820 --> 00:08:23.820
Vậy nên, chuyện đã xảy ra là,
một sinh viên cao học ở Trung Quốc

00:08:23.820 --> 00:08:25.820
Lulu Qian, làm một việc rất tốt.

00:08:25.820 --> 00:08:27.820
Cô ấy viết toàn bộ phần mềm

00:08:27.820 --> 00:08:29.820
để thiết kế và xây dựng DNA origami này,

00:08:29.820 --> 00:08:32.820
một tác phẩm tuyệt vời từ Trung Quốc,
có cả Đài Loan nữa,

00:08:32.820 --> 00:08:35.820
và bạn có thể thấy nó đến từ nơi ít được
kiểm soát nhất trên thế giới, đúng không?

00:08:35.820 --> 00:08:37.820
(Cười lớn)

00:08:38.820 --> 00:08:40.340
Do đó, nó chạy rất tốt,

00:08:40.820 --> 00:08:42.820
và bạn có thể làm ra
mọi hình dạng và hoa văn.

00:08:43.820 --> 00:08:46.820
Bạn có thể làm được bản đồ nước Mỹ
và đánh vần DNA bằng DNA

00:08:46.820 --> 00:08:49.820
Và điều khéo léo ở đây là,

00:08:49.820 --> 00:08:51.820
nó thực sự là một tuyệt tác
của công nghệ nano

00:08:51.820 --> 00:08:52.820
nhưng tuyệt tác đó

00:08:52.820 --> 00:08:54.820
lại là thứ bạn cần để làm ra
mạch điện nano.

00:08:54.820 --> 00:08:56.820
Do đó, bạn có thể đặt
các phần của mạch điện vào khuôn,

00:08:56.820 --> 00:08:58.820
như bóng đèn và công tắc.

00:08:58.820 --> 00:09:01.820
Để cho nó tự lắp ráp
và bạn sẽ có một kiểu mạch điện.

00:09:01.820 --> 00:09:04.820
Và bạn có thể rửa trôi DNA đi,
để lại mỗi mạch điện thôi.

00:09:04.820 --> 00:09:06.820
Đây là thứ mà đồng nghiệp của tôi
ở Caltech làm.

00:09:06.820 --> 00:09:09.820
Họ lấy DNA origami,
sắp xếp thêm ống carbon nano

00:09:09.820 --> 00:09:11.820
làm một công tắc nhỏ, bạn thấy ở đây,
nối dây lại,

00:09:11.820 --> 00:09:14.820
kiểm tra và chắc rằng nó là một công tắc.

00:09:14.820 --> 00:09:16.820
Bây giờ, nó chỉ là một công tắc đơn,

00:09:16.820 --> 00:09:20.820
và bạn cần cỡ nửa tỉ cái cho một máy tính,
nên chúng ta cần phải làm rất nhiều.

00:09:20.820 --> 00:09:22.820
Nhưng nó rất triển vọng

00:09:22.820 --> 00:09:27.820
bởi vì origami có thể sắp xếp những phần
chỉ cỡ 1/10 kích thước

00:09:27.820 --> 00:09:28.820
của chúng trong một máy tính bình thường

00:09:28.820 --> 00:09:31.820
Cho nên nó rất triển vọng
trong việc tạo ra những máy tính nhỏ.

00:09:31.820 --> 00:09:34.820
Bây giờ, tôi muốn quay lại với
máy biên dịch

00:09:34.820 --> 00:09:38.420
DNA origami là bằng chứng cho thấy
máy biên dịch thật sự hoạt động.

00:09:38.820 --> 00:09:40.820
Bạn bắt đầu bằng thứ gì đó trong máy tính.

00:09:40.820 --> 00:09:43.820
Bạn đang có một mô tả cấp cao
của chương trình máy tính,

00:09:43.820 --> 00:09:45.820
bản mô tả cấp cao của cái origami này.

00:09:45.820 --> 00:09:48.820
Bạn có thể biên dịch nó thành các phân tử,
gửi tới máy tổng hợp,

00:09:48.820 --> 00:09:49.820
và nó đã có thể hoạt động.

00:09:49.820 --> 00:09:53.820
Hóa ra có một công ty làm ra phần mềm này

00:09:53.820 --> 00:09:55.820
tốt hơn những câu lệnh xấu xí của tôi

00:09:55.820 --> 00:09:56.820
sẽ cho phép chúng ta làm ra nó

00:09:56.820 --> 00:09:58.820
theo một cách đẹp, dễ nhìn,
và được máy tính bổ trợ.

00:09:59.820 --> 00:10:00.820
Bây giờ bạn có thể hỏi rằng

00:10:00.820 --> 00:10:02.820
tại sao DNA origami không là
đoạn kết câu chuyện?

00:10:02.820 --> 00:10:04.820
Bạn có máy biên dịch phân tử,
bạn có thể làm được bất cứ thứ gì bạn muốn

00:10:04.820 --> 00:10:07.820
Thực tế nó không được dùng như vậy.

00:10:07.820 --> 00:10:10.820
Nếu bạn muốn tạo ra một con người
từ DNA origami,

00:10:10.820 --> 00:10:12.820
bạn sẽ cần một chuỗi rất dài,

00:10:12.820 --> 00:10:15.820
10 triệu tỷ tỷ base.

00:10:15.820 --> 00:10:17.820
Nó sẽ là đoạn DNA dài 3 năm ánh sáng,

00:10:17.820 --> 00:10:19.820
nên chúng ta sẽ không làm điều đó.

00:10:19.820 --> 00:10:21.820
Chúng ta sẽ chuyển sang công nghệ khác,

00:10:21.820 --> 00:10:23.820
gọi là thuật toán tự dịch mã của viên gạch

00:10:23.820 --> 00:10:25.820
Nó được khởi xướng bởi Erik Winfree,

00:10:25.820 --> 00:10:26.820
và những gì nó làm là,

00:10:26.820 --> 00:10:30.820
tạo ra các viên gạch chỉ bằng 1/100 lần
kích cỡ của DNA origami.

00:10:30.820 --> 00:10:32.820
Bạn phóng to nó lên,
bạn chỉ thấy bốn sợi DNA

00:10:33.820 --> 00:10:35.820
và chúng có những sợi đơn nhỏ hơn bện vào

00:10:35.820 --> 00:10:37.820
để kết nối với những viên khác,
nếu trùng khớp.

00:10:37.820 --> 00:10:40.820
Và chúng ta sẽ vẽ những viên gạch này
như những hình vuông nhỏ.

00:10:41.820 --> 00:10:43.820
Nếu như bạn nhìn vào đuôi của
các đoạn DNA nhỏ này,

00:10:43.820 --> 00:10:46.820
bạn có thể thấy chúng thực sự tạo thành
hoa văn bàn cờ.

00:10:46.820 --> 00:10:49.820
Vậy nên, những viên gạch này làm nên
một bàn cờ tự ráp phức tạp.

00:10:49.820 --> 00:10:51.820
Và cái chính ở đây là, nếu bạn không hiểu được,

00:10:51.820 --> 00:10:54.820
những viên gạch đó là một dạng
lập trình phân tử

00:10:54.820 --> 00:10:57.820
và nó có thể cho ra một hoa văn nhất định.

00:10:57.820 --> 00:10:59.820
Và phần thú vị của nó ở đây là

00:10:59.820 --> 00:11:01.820
mọi chương trình máy tính
đều có thể được dịch ra thành

00:11:01.820 --> 00:11:04.820
một trong các chương trình viên gạch này,
đặc biệt là việc tính toán.

00:11:04.820 --> 00:11:07.820
Nên bạn có thể nghĩ ra
một tập hợp các viên gạch

00:11:07.820 --> 00:11:10.820
mà khi kết nối với nhau, tạo ra
một bộ đếm nhị phân nhỏ

00:11:10.820 --> 00:11:12.820
hơn là một bàn cờ.

00:11:12.820 --> 00:11:15.820
Do đó bạn có thể đọc được số nhị phân của
năm, sáu, và bảy.

00:11:15.820 --> 00:11:18.820
Và muốn phép toán này đúng ngay từ lúc khởi đầu,

00:11:18.820 --> 00:11:20.820
bạn cần một đầu vào, một kiểu hạt giống.

00:11:20.820 --> 00:11:22.820
Bạn có thể dùng DNA origami làm hạt giống.

00:11:22.820 --> 00:11:24.820
Bạn có thể mã hóa con số 32

00:11:24.820 --> 00:11:26.820
vào phía bên phải của DNA origami,

00:11:26.820 --> 00:11:28.820
và khi bạn thêm những viên gạch vào bộ đếm

00:11:28.820 --> 00:11:31.820
nó sẽ bắt đầu đếm, nó sẽ đọc 32 con số

00:11:31.820 --> 00:11:33.820
và sẽ dừng ở 32.

00:11:33.820 --> 00:11:36.820
Vậy nên điều chúng tôi đã làm là tìm ra

00:11:36.820 --> 00:11:39.820
một chương trình phân tử
biết chỗ nào phải dừng.

00:11:39.820 --> 00:11:41.820
Nó biết lúc nào cần dừng phát triển
vì nó có thể đếm được.

00:11:41.820 --> 00:11:43.820
Nó biết nó đã lớn được bao nhiêu.

00:11:43.820 --> 00:11:46.820
Vậy nên nó đã trả lời được
câu hỏi đầu tiên tôi nêu ra.

00:11:46.820 --> 00:11:49.820
Nhưng nó vẫn chưa trả lời được
liệu em bé có thể làm được việc đó không.

00:11:49.820 --> 00:11:53.820
Vậy bây giờ chúng ta sẽ dùng cách đếm này

00:11:53.820 --> 00:11:54.820
và cố gắng áp đặt cho những vật lớn hơn
DNA origami có thể làm.

00:11:54.820 --> 00:11:57.820
Đây là DNA origami,
và điều ta có thể làm là

00:11:57.820 --> 00:12:00.820
viết 32 con số lên hai cạnh của nó,

00:12:00.820 --> 00:12:02.820
và ta có thể dùng cái bình tưới cây

00:12:02.820 --> 00:12:06.820
thêm vào đó những viên gạch,
và bắt đầu trồng những viên gạch

00:12:06.820 --> 00:12:08.820
và tạo ra một ô vuông.

00:12:08.820 --> 00:12:11.820
Bộ đếm hoạt động như một bộ khuôn

00:12:11.820 --> 00:12:13.820
để làm đầy ô vuông ở chính giữa của nó.

00:12:13.820 --> 00:12:14.820
Do đó, chúng ta đã thành công

00:12:14.820 --> 00:12:17.820
trong việc làm ra thứ gì đó lớn hơn nhiều
so với DNA origami

00:12:17.820 --> 00:12:20.820
bằng cách kết hợp DNA origami
với các viên gạch.

00:12:20.820 --> 00:12:23.820
Và điều dễ dàng ở đây
là chúng có thể được tái lập trình.

00:12:23.820 --> 00:12:27.820
Bạn có thể chỉ thay đổi vài sợi DNA
trong chuỗi nhị phân này

00:12:27.820 --> 00:12:30.820
và bạn sẽ có 96 con số thay vì 32.

00:12:30.820 --> 00:12:33.820
Nếu như bạn làm như vậy,
khối origami vẫn giữ nguyên kích thước,

00:12:33.820 --> 00:12:37.820
nhưng kết quả bạn sẽ nhận được khối vuông
lớn gấp ba lần khối ban đầu.

00:12:38.820 --> 00:12:39.820
Tóm lại, điều tôi muốn nói ở đây

00:12:39.820 --> 00:12:41.820
là sự phát triển.

00:12:41.820 --> 00:12:44.820
Bạn có một chương trình máy tính
rất nhạy cảm

00:12:44.820 --> 00:12:47.820
khi mà mọi thay đổi nhỏ
-- những đột biến lẻ, rất nhỏ thôi --

00:12:47.820 --> 00:12:49.820
có thể thay đổi một khối vuông
với kích cỡ đầu

00:12:49.820 --> 00:12:52.820
và tạo ra thứ lớn hơn nhiều lần.

00:12:53.820 --> 00:12:56.820
Bây giờ, sử dụng kiểu đếm này để tính toán

00:12:56.820 --> 00:12:58.820
và xây dựng nên những thứ này

00:12:58.820 --> 00:13:00.820
bằng cách phát triển đã nói trên

00:13:00.820 --> 00:13:04.820
phần nào đã trả lời được
câu hỏi của Craig Venter.

00:13:04.820 --> 00:13:06.820
Do đó, bạn có thể hỏi
cần bao nhiêu sợi DNA

00:13:06.820 --> 00:13:08.820
để làm ra khối vuông
với kích thước định sẵn?

00:13:08.820 --> 00:13:13.820
Nếu ta muốn khối vuông đó có kích thước
cỡ 10, 100 hay 1000

00:13:13.820 --> 00:13:15.820
Nếu chỉ sử dụng DNA origami,

00:13:15.820 --> 00:13:18.820
ta sẽ cần một lượng sợi DNA vừa với

00:13:18.820 --> 00:13:20.820
kích cỡ của khối vuông;

00:13:20.820 --> 00:13:22.820
vậy là 100, 10 000,
thậm chí cả triệu sợi DNA.

00:13:22.820 --> 00:13:24.820
Điều đó nằm ngoài khả năng của ta.

00:13:24.820 --> 00:13:26.820
Nhưng nếu như ta sử dụng
một ít tính toán ở đây

00:13:26.820 --> 00:13:30.820
dùng origami, cộng thêm vài viên gạch
có thể đếm được,

00:13:30.820 --> 00:13:33.820
chúng ta sẽ chỉ cần dùng
100, 200 hoặc 300 sợi DNA.

00:13:33.820 --> 00:13:38.820
Có thể thấy, ta có thể giảm theo hàm số mũ
số lượng sợi DNA ta cần dùng,

00:13:38.820 --> 00:13:41.820
nếu ta sử dụng cách tính trên
và một vài tính toán nho nhỏ.

00:13:41.820 --> 00:13:44.820
Vì vậy việc tính toán có sức mạnh lớn

00:13:44.820 --> 00:13:47.820
trong việc giảm số phân tử bạn cần
để tạo ra thứ gì đó,

00:13:47.820 --> 00:13:50.820
giảm kích thước bộ gen bạn đang xây dựng.

00:13:50.820 --> 00:13:53.820
Cuối cùng, tôi sẽ quay lại với
cái ý tưởng điên rồ ban đầu

00:13:53.820 --> 00:13:55.820
về việc máy tính tạo ra máy tính.

00:13:55.820 --> 00:13:58.820
Nếu như bạn nhìn vào khối vuông bạn tạo ra
bằng origami

00:13:58.820 --> 00:14:00.820
và một vài bộ đếm lớn lên từ đó,

00:14:00.820 --> 00:14:03.820
hoa văn của nó chính là hoa văn bạn cần

00:14:03.820 --> 00:14:04.820
để tạo nên bộ nhớ.

00:14:04.820 --> 00:14:07.820
Vậy nên nếu bạn thêm vài sợi dây nối
và chuyển vào các viên gạch

00:14:07.820 --> 00:14:10.820
thay vì vào các sợi DNA kim dập

00:14:10.820 --> 00:14:13.820
chúng sẽ tự lắp ráp thành
những mạch điện phức tạp,

00:14:13.820 --> 00:14:16.820
mạch phân giải tín hiệu,
mà bạn cần thêm vào bộ nhớ này.

00:14:16.820 --> 00:14:18.820
Do đó bạn có thể tự làm ra
một mạch điện phức tạp

00:14:18.820 --> 00:14:20.820
sử dụng một chút tính toán.

00:14:20.820 --> 00:14:23.820
Đó chính là máy tính phân tử
xây dựng máy tính điện tử.

00:14:23.820 --> 00:14:26.820
Bây giờ, bạn hỏi chúng tôi
đã đi theo hướng này được bao lâu rồi?

00:14:26.820 --> 00:14:29.820
Về mặt thực nghiệm, đây là những gì
chúng tôi đã làm trong suốt năm qua.

00:14:29.820 --> 00:14:31.820
Đây là một DNA origami hình tam giác,

00:14:32.820 --> 00:14:34.820
và đây là những viên gạch bên trong nó.

00:14:34.820 --> 00:14:36.820
Và bạn có thể thấy cách nó đếm như thế nào

00:14:36.820 --> 00:14:48.820
1, 2, 3 ,4 ,5 ,6, 9, 10, 11, 12, 17.

00:14:48.820 --> 00:14:52.820
Nó có sai sót tí,
nhưng ít ra nó vẫn đếm lên

00:14:52.820 --> 00:14:53.820
(Cười lớn)

00:14:53.820 --> 00:14:56.820
Thật ra chúng tôi đã có ý tưởng này
từ chín năm trước rồi,

00:14:56.820 --> 00:14:59.820
và đó là khoảng thời gian cần thiết để có thể

00:14:59.820 --> 00:15:01.820
làm ra được thứ như vầy, nên tôi nghĩ rằng
chúng tôi đã làm được kha khá thứ.

00:15:01.820 --> 00:15:03.820
Chúng tôi cũng lên ý tưởng
sửa chữa các lỗi này.

00:15:03.820 --> 00:15:05.820
Và tôi nghĩ trong 5 năm hay 10 năm nữa,

00:15:05.820 --> 00:15:07.820
tôi sẽ làm được những khối vuông kiểu này

00:15:07.820 --> 00:15:10.820
và có thể làm ra được
những mạch điện tự ráp khác nữa.

00:15:10.820 --> 00:15:14.820
Vì thế, tôi muốn bạn rút ra được
kết luận gì sau bài nói này?

00:15:14.820 --> 00:15:16.820
Tôi muốn bạn nhớ rằng

00:15:16.820 --> 00:15:20.820
để tạo nên sự sống phong phú
và phức tạp như bây giờ,

00:15:20.820 --> 00:15:22.820
cuộc sống cần tính toán
để làm được điều đó.

00:15:22.820 --> 00:15:26.820
Và việc tính toán đó
dựa trên lập trình phân tử

00:15:26.820 --> 00:15:28.820
và để có thể hiểu được điều này
và sử dụng nó tốt hơn,

00:15:28.820 --> 00:15:30.820
như Feynnan từng nói,

00:15:30.820 --> 00:15:32.820
chúng ta cần xây dựng thứ gì đó
để hiểu về nó.

00:15:32.820 --> 00:15:36.820
Vậy nên ta sẽ sử dụng phân tử
và tái lập trình lại thứ này,

00:15:36.820 --> 00:15:38.820
xây dựng mọi thứ lại từ đầu,

00:15:38.820 --> 00:15:41.820
sử dụng DNA theo cách
tự nhiên chưa bao giờ dùng,

00:15:41.820 --> 00:15:43.820
sử dụng DNA origami,

00:15:43.820 --> 00:15:46.820
và DNA origami để ươm mầm nên
thuật toán tự ráp này.

00:15:46.820 --> 00:15:48.910
Bạn biết đó, tất cả điều này rất hay,

00:15:48.910 --> 00:15:50.820
nhưng thứ tôi muốn bạn mang về
sau buổi nói chuyện này,

00:15:50.820 --> 00:15:52.820
từ một vài câu hỏi lớn,

00:15:52.820 --> 00:15:55.820
là lập trình phân tử này không phải chỉ về
tạo ra đồ vật.

00:15:55.820 --> 00:15:57.820
Nó không phải chỉ tạo ra ----

00:15:57.820 --> 00:15:59.820
nó tạo ra điện thoại và mạch điện tự ráp.

00:15:59.820 --> 00:16:01.820
Điều trọng tâm của nó
là đem khoa học máy tính

00:16:01.820 --> 00:16:04.820
và nhìn vào các câu hỏi lớn
dưới góc nhìn khác,

00:16:04.820 --> 00:16:06.820
thêm vào vài phiên bản khác
của các câu hỏi này

00:16:06.820 --> 00:16:08.820
và cố gắng hiểu được làm cách nào sinh học

00:16:08.820 --> 00:16:11.380
có thể làm được những điều phi thường.
Cảm ơn.

00:16:11.820 --> 00:16:18.820
(Vỗ tay)

