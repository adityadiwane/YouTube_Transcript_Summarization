WEBVTT
Kind: captions
Language: en

00:00:15.260 --> 00:00:17.260
Today I'd like to show you

00:00:17.260 --> 00:00:19.260
the future of the way we make things.

00:00:19.260 --> 00:00:21.260
I believe that soon our buildings and machines

00:00:21.260 --> 00:00:23.260
will be self-assembling,

00:00:23.260 --> 00:00:25.260
replicating and repairing themselves.

00:00:25.260 --> 00:00:27.260
So I'm going to show you

00:00:27.260 --> 00:00:29.260
what I believe is the current state of manufacturing,

00:00:29.260 --> 00:00:32.260
and then compare that to some natural systems.

00:00:32.260 --> 00:00:35.260
So in the current state of manufacturing, we have skyscrapers --

00:00:35.260 --> 00:00:37.260
two and a half years [of assembly time],

00:00:37.260 --> 00:00:39.260
500,000 to a million parts,

00:00:39.260 --> 00:00:41.260
fairly complex,

00:00:41.260 --> 00:00:44.260
new, exciting technologies in steel, concrete, glass.

00:00:44.260 --> 00:00:46.260
We have exciting machines

00:00:46.260 --> 00:00:48.260
that can take us into space --

00:00:48.260 --> 00:00:51.260
five years [of assembly time], 2.5 million parts.

00:00:51.260 --> 00:00:54.260
But on the other side, if you look at the natural systems,

00:00:54.260 --> 00:00:56.260
we have proteins

00:00:56.260 --> 00:00:58.260
that have two million types,

00:00:58.260 --> 00:01:00.260
can fold in 10,000 nanoseconds,

00:01:00.260 --> 00:01:02.260
or DNA with three billion base pairs

00:01:02.260 --> 00:01:05.260
we can replicate in roughly an hour.

00:01:05.260 --> 00:01:07.260
So there's all of this complexity

00:01:07.260 --> 00:01:09.260
in our natural systems,

00:01:09.260 --> 00:01:11.260
but they're extremely efficient,

00:01:11.260 --> 00:01:13.260
far more efficient than anything we can build,

00:01:13.260 --> 00:01:15.260
far more complex than anything we can build.

00:01:15.260 --> 00:01:17.260
They're far more efficient in terms of energy.

00:01:17.260 --> 00:01:20.260
They hardly ever make mistakes.

00:01:20.260 --> 00:01:22.260
And they can repair themselves for longevity.

00:01:22.260 --> 00:01:25.260
So there's something super interesting about natural systems.

00:01:25.260 --> 00:01:27.260
And if we can translate that

00:01:27.260 --> 00:01:29.260
into our built environment,

00:01:29.260 --> 00:01:31.260
then there's some exciting potential for the way that we build things.

00:01:31.260 --> 00:01:34.260
And I think the key to that is self-assembly.

00:01:34.260 --> 00:01:37.260
So if we want to utilize self-assembly in our physical environment,

00:01:37.260 --> 00:01:39.260
I think there's four key factors.

00:01:39.260 --> 00:01:41.260
The first is that we need to decode

00:01:41.260 --> 00:01:43.260
all of the complexity of what we want to build --

00:01:43.260 --> 00:01:45.260
so our buildings and machines.

00:01:45.260 --> 00:01:47.260
And we need to decode that into simple sequences --

00:01:47.260 --> 00:01:49.260
basically the DNA of how our buildings work.

00:01:49.260 --> 00:01:51.260
Then we need programmable parts

00:01:51.260 --> 00:01:53.260
that can take that sequence

00:01:53.260 --> 00:01:56.260
and use that to fold up, or reconfigure.

00:01:56.260 --> 00:01:59.260
We need some energy that's going to allow that to activate,

00:01:59.260 --> 00:02:02.260
allow our parts to be able to fold up from the program.

00:02:02.260 --> 00:02:04.260
And we need some type of error correction redundancy

00:02:04.260 --> 00:02:07.260
to guarantee that we have successfully built what we want.

00:02:07.260 --> 00:02:09.260
So I'm going to show you a number of projects

00:02:09.260 --> 00:02:11.260
that my colleagues and I at MIT are working on

00:02:11.260 --> 00:02:13.260
to achieve this self-assembling future.

00:02:13.260 --> 00:02:16.260
The first two are the MacroBot and DeciBot.

00:02:16.260 --> 00:02:20.260
So these projects are large-scale reconfigurable robots --

00:02:20.260 --> 00:02:23.260
8 ft., 12 ft. long proteins.

00:02:23.260 --> 00:02:26.260
They're embedded with mechanical electrical devices, sensors.

00:02:26.260 --> 00:02:28.260
You decode what you want to fold up into,

00:02:28.260 --> 00:02:30.260
into a sequence of angles --

00:02:30.260 --> 00:02:32.260
so negative 120, negative 120, 0, 0,

00:02:32.260 --> 00:02:35.260
120, negative 120 -- something like that;

00:02:35.260 --> 00:02:37.260
so a sequence of angles, or turns,

00:02:37.260 --> 00:02:40.260
and you send that sequence through the string.

00:02:40.260 --> 00:02:43.260
Each unit takes its message -- so negative 120 --

00:02:43.260 --> 00:02:45.260
it rotates to that, checks if it got there

00:02:45.260 --> 00:02:48.260
and then passes it to its neighbor.

00:02:48.260 --> 00:02:50.260
So these are the brilliant scientists,

00:02:50.260 --> 00:02:52.260
engineers, designers that worked on this project.

00:02:52.260 --> 00:02:54.260
And I think it really brings to light:

00:02:54.260 --> 00:02:56.260
Is this really scalable?

00:02:56.260 --> 00:02:58.260
I mean, thousands of dollars, lots of man hours

00:02:58.260 --> 00:03:01.260
made to make this eight-foot robot.

00:03:01.260 --> 00:03:04.260
Can we really scale this up? Can we really embed robotics into every part?

00:03:04.260 --> 00:03:06.260
The next one questions that

00:03:06.260 --> 00:03:08.260
and looks at passive nature,

00:03:08.260 --> 00:03:11.260
or passively trying to have reconfiguration programmability.

00:03:11.260 --> 00:03:13.260
But it goes a step further,

00:03:13.260 --> 00:03:15.260
and it tries to have actual computation.

00:03:15.260 --> 00:03:17.260
It basically embeds the most fundamental building block of computing,

00:03:17.260 --> 00:03:19.260
the digital logic gate,

00:03:19.260 --> 00:03:21.260
directly into your parts.

00:03:21.260 --> 00:03:23.260
So this is a NAND gate.

00:03:23.260 --> 00:03:25.260
You have one tetrahedron which is the gate

00:03:25.260 --> 00:03:27.260
that's going to do your computing,

00:03:27.260 --> 00:03:29.260
and you have two input tetrahedrons.

00:03:29.260 --> 00:03:32.260
One of them is the input from the user, as you're building your bricks.

00:03:32.260 --> 00:03:35.260
The other one is from the previous brick that was placed.

00:03:35.260 --> 00:03:38.260
And then it gives you an output in 3D space.

00:03:38.260 --> 00:03:40.260
So what this means

00:03:40.260 --> 00:03:43.260
is that the user can start plugging in what they want the bricks to do.

00:03:43.260 --> 00:03:45.260
It computes on what it was doing before

00:03:45.260 --> 00:03:47.260
and what you said you wanted it to do.

00:03:47.260 --> 00:03:49.260
And now it starts moving in three-dimensional space --

00:03:49.260 --> 00:03:51.260
so up or down.

00:03:51.260 --> 00:03:54.260
So on the left-hand side, [1,1] input equals 0 output, which goes down.

00:03:54.260 --> 00:03:56.260
On the right-hand side,

00:03:56.260 --> 00:03:59.260
[0,0] input is a 1 output, which goes up.

00:03:59.260 --> 00:04:01.260
And so what that really means

00:04:01.260 --> 00:04:03.260
is that our structures now contain the blueprints

00:04:03.260 --> 00:04:05.260
of what we want to build.

00:04:05.260 --> 00:04:08.260
So they have all of the information embedded in them of what was constructed.

00:04:08.260 --> 00:04:11.260
So that means that we can have some form of self-replication.

00:04:11.260 --> 00:04:14.260
In this case I call it self-guided replication,

00:04:14.260 --> 00:04:16.260
because your structure contains the exact blueprints.

00:04:16.260 --> 00:04:18.260
If you have errors, you can replace a part.

00:04:18.260 --> 00:04:21.260
All the local information is embedded to tell you how to fix it.

00:04:21.260 --> 00:04:23.260
So you could have something that climbs along and reads it

00:04:23.260 --> 00:04:25.260
and can output at one to one.

00:04:25.260 --> 00:04:27.260
It's directly embedded; there's no external instructions.

00:04:27.260 --> 00:04:30.260
So the last project I'll show is called Biased Chains,

00:04:30.260 --> 00:04:33.260
and it's probably the most exciting example that we have right now

00:04:33.260 --> 00:04:35.260
of passive self-assembly systems.

00:04:35.260 --> 00:04:37.260
So it takes the reconfigurability

00:04:37.260 --> 00:04:39.260
and programmability

00:04:39.260 --> 00:04:42.260
and makes it a completely passive system.

00:04:43.260 --> 00:04:45.260
So basically you have a chain of elements.

00:04:45.260 --> 00:04:47.260
Each element is completely identical,

00:04:47.260 --> 00:04:49.260
and they're biased.

00:04:49.260 --> 00:04:52.260
So each chain, or each element, wants to turn right or left.

00:04:52.260 --> 00:04:55.260
So as you assemble the chain, you're basically programming it.

00:04:55.260 --> 00:04:58.260
You're telling each unit if it should turn right or left.

00:04:58.260 --> 00:05:01.260
So when you shake the chain,

00:05:01.260 --> 00:05:03.260
it then folds up

00:05:03.260 --> 00:05:06.260
into any configuration that you've programmed in --

00:05:06.260 --> 00:05:08.260
so in this case, a spiral,

00:05:08.260 --> 00:05:11.260
or in this case,

00:05:11.260 --> 00:05:14.260
two cubes next to each other.

00:05:14.260 --> 00:05:16.260
So you can basically program

00:05:16.260 --> 00:05:18.260
any three-dimensional shape --

00:05:18.260 --> 00:05:21.260
or one-dimensional, two-dimensional -- up into this chain completely passively.

00:05:21.260 --> 00:05:23.260
So what does this tell us about the future?

00:05:23.260 --> 00:05:25.260
I think that it's telling us

00:05:25.260 --> 00:05:28.260
that there's new possibilities for self-assembly, replication, repair

00:05:28.260 --> 00:05:31.260
in our physical structures, our buildings, machines.

00:05:31.260 --> 00:05:33.260
There's new programmability in these parts.

00:05:33.260 --> 00:05:35.260
And from that you have new possibilities for computing.

00:05:35.260 --> 00:05:37.260
We'll have spatial computing.

00:05:37.260 --> 00:05:39.260
Imagine if our buildings, our bridges, machines,

00:05:39.260 --> 00:05:41.260
all of our bricks could actually compute.

00:05:41.260 --> 00:05:43.260
That's amazing parallel and distributed computing power,

00:05:43.260 --> 00:05:45.260
new design possibilities.

00:05:45.260 --> 00:05:47.260
So it's exciting potential for this.

00:05:47.260 --> 00:05:49.260
So I think these projects I've showed here

00:05:49.260 --> 00:05:51.260
are just a tiny step towards this future,

00:05:51.260 --> 00:05:53.260
if we implement these new technologies

00:05:53.260 --> 00:05:55.260
for a new self-assembling world.

00:05:55.260 --> 00:05:57.260
Thank you.

00:05:57.260 --> 00:05:59.260
(Applause)

