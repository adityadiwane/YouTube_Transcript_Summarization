WEBVTT
Kind: captions
Language: pt-PT

00:00:00.000 --> 00:00:07.000
Tradutor: Nuno Miranda Ribeiro
Revisora: Miguel Cabral de Pinho

00:00:15.260 --> 00:00:17.260
Hoje gostaria de vos mostrar

00:00:17.260 --> 00:00:19.260
o futuro da forma como construímos coisas.

00:00:19.260 --> 00:00:21.260
Acredito que em breve os nossos edifícios e máquinas

00:00:21.260 --> 00:00:23.260
serão capazes de se auto-montar,

00:00:23.260 --> 00:00:25.260
de se replicarem e de se repararem a si mesmos.

00:00:25.260 --> 00:00:27.260
Por isso vou mostrar-vos

00:00:27.260 --> 00:00:29.260
o que eu penso ser o estado actual dos processos de fabrico,

00:00:29.260 --> 00:00:32.260
e depois compará-los a alguns sistemas naturais.

00:00:32.260 --> 00:00:35.260
Então, no estado actual dos processos de fabrico, temos arranha-céus --

00:00:35.260 --> 00:00:37.260
dois anos e meio,

00:00:37.260 --> 00:00:39.260
com 500.000 a 1 milhão de peças,

00:00:39.260 --> 00:00:41.260
bastante complexo,

00:00:41.260 --> 00:00:44.260
novas e entusiasmantes tecnologias no aço, betão, vidro.

00:00:44.260 --> 00:00:46.260
Temos máquinas entusiasmantes

00:00:46.260 --> 00:00:48.260
que nos podem levar para o espaço --

00:00:48.260 --> 00:00:51.260
cinco anos, 2,5 milhões de peças.

00:00:51.260 --> 00:00:54.260
Mas por outro lado, se olharmos para os sistemas naturais,

00:00:54.260 --> 00:00:56.260
temos proteínas

00:00:56.260 --> 00:00:58.260
que têm dois milhões de tipos,

00:00:58.260 --> 00:01:00.260
podem-se dobrar em 10.000 nanossegundos,

00:01:00.260 --> 00:01:02.260
ou o ADN com três mil milhões de pares base

00:01:02.260 --> 00:01:05.260
que podemos replicar em cerca de uma hora.

00:01:05.260 --> 00:01:07.260
Então, existe toda esta complexidade

00:01:07.260 --> 00:01:09.260
nos nossos sistemas naturais,

00:01:09.260 --> 00:01:11.260
mas eles são extremamente eficientes,

00:01:11.260 --> 00:01:13.260
bem mais eficientes do que qualquer coisa que podemos construir,

00:01:13.260 --> 00:01:15.260
bem mais complexos do que qualquer coisa que podemos construir.

00:01:15.260 --> 00:01:17.260
São bem mais eficientes em termos de energia.

00:01:17.260 --> 00:01:20.260
Raramente cometem erros.

00:01:20.260 --> 00:01:22.260
E conseguem regenerar-se para ter longevidade.

00:01:22.260 --> 00:01:25.260
Então, há algo de super interessante acerca dos sistemas naturais.

00:01:25.260 --> 00:01:27.260
E se conseguirmos traduzir isso

00:01:27.260 --> 00:01:29.260
no nosso ambiente construído,

00:01:29.260 --> 00:01:31.260
então há algum potencial entusiasmante para a forma como construímos coisas.

00:01:31.260 --> 00:01:34.260
E eu penso que a chave para isso é a automontagem.

00:01:34.260 --> 00:01:37.260
Então, se queremos utilizar a automontagem no nosso meio físico,

00:01:37.260 --> 00:01:39.260
penso que há quatro factores chave.

00:01:39.260 --> 00:01:41.260
O primeiro é que precisamos de descodificar

00:01:41.260 --> 00:01:43.260
toda a complexidade daquilo que queremos construir --

00:01:43.260 --> 00:01:45.260
os nossos edifícios e máquinas.

00:01:45.260 --> 00:01:47.260
E precisamos de descodificá-los em sequências simples --

00:01:47.260 --> 00:01:49.260
basicamente o ADN de como os nossos edifícios funcionam.

00:01:49.260 --> 00:01:51.260
Depois precisamos de componentes programáveis

00:01:51.260 --> 00:01:53.260
que possam pegar naquela sequência

00:01:53.260 --> 00:01:56.260
e usá-la para se dobrarem ou reconfigurarem.

00:01:56.260 --> 00:01:59.260
Precisamos de alguma energia que possa activá-lo,

00:01:59.260 --> 00:02:02.260
permitir que os componentes sejam capazes de se configurar a partir do programa.

00:02:02.260 --> 00:02:04.260
E precisamos de algum tipo de redundância que corrija erros

00:02:04.260 --> 00:02:07.260
para garantir que construímos com sucesso o que queremos.

00:02:07.260 --> 00:02:09.260
Vou então mostrar-vos uma série de projectos

00:02:09.260 --> 00:02:11.260
em que eu e os meus colegas estamos a trabalhar no MIT

00:02:11.260 --> 00:02:13.260
para alcançar este futuro de automontagem.

00:02:13.260 --> 00:02:16.260
Os primeiros dois são o MacroBot e o DeciBot.

00:02:16.260 --> 00:02:20.260
Estes projectos são robôs reconfiguráveis de grande escala --

00:02:20.260 --> 00:02:23.260
proteínas de 2,5 - 3,5 metros.

00:02:23.260 --> 00:02:26.260
Têm dispositivos, sensores electromecânicos embutidos.

00:02:26.260 --> 00:02:28.260
Descodifica-se o que se quer ver dobrar,

00:02:28.260 --> 00:02:30.260
numa sequência de ângulos --

00:02:30.260 --> 00:02:32.260
então menos 120, menos 120, 0, 0,

00:02:32.260 --> 00:02:35.260
120, menos 120 -- algo assim;

00:02:35.260 --> 00:02:37.260
uma sequência de ângulos, ou curvas,

00:02:37.260 --> 00:02:40.260
e envia-se essa sequência ao longo do fio.

00:02:40.260 --> 00:02:43.260
Cada unidade recebe a sua mensagem -- então, menos 120.

00:02:43.260 --> 00:02:45.260
roda esse valor, verifica se chegou lá

00:02:45.260 --> 00:02:48.260
e depois passa-o ao seu vizinho.

00:02:48.260 --> 00:02:50.260
São estes, então, os cientistas,

00:02:50.260 --> 00:02:52.260
engenheiros e designers brilhantes que trabalharam neste projecto.

00:02:52.260 --> 00:02:54.260
E penso que isto realmente traz à luz o seguinte:

00:02:54.260 --> 00:02:56.260
Isto é realmente escalável?

00:02:56.260 --> 00:02:58.260
Quer dizer, milhares de euros, muitas Homem-hora

00:02:58.260 --> 00:03:01.260
para conseguir construir este robô de 2,5 metros.

00:03:01.260 --> 00:03:04.260
Será que conseguimos mesmo aumentar a escala? Conseguimos mesmo embutir robótica em cada componente?

00:03:04.260 --> 00:03:06.260
O próximo questiona isso

00:03:06.260 --> 00:03:08.260
e olha para a natureza passiva,

00:03:08.260 --> 00:03:11.260
ou tenta passivamente obter a programabilidade da reconfiguração.

00:03:11.260 --> 00:03:13.260
Mas vai um passo mais longe,

00:03:13.260 --> 00:03:15.260
e tenta ter verdadeira computação.

00:03:15.260 --> 00:03:17.260
Basicamente embute o alicerce mais fundamental da computação,

00:03:17.260 --> 00:03:19.260
a porta lógica digital,

00:03:19.260 --> 00:03:21.260
directamente nos seus componentes.

00:03:21.260 --> 00:03:23.260
Isto é uma porta NAND.

00:03:23.260 --> 00:03:25.260
Temos um tetraedro que é a porta

00:03:25.260 --> 00:03:27.260
que vai fazer a nossa computação,

00:03:27.260 --> 00:03:29.260
e temos dois tetraedros que recebem dados.

00:03:29.260 --> 00:03:32.260
Um deles recebe dados do utilizador, à medida que se constroem os tijolos.

00:03:32.260 --> 00:03:35.260
O outro recebe-os do último tijolo que foi colocado.

00:03:35.260 --> 00:03:38.260
E depois dá-nos um resultado em espaço tridimensional.

00:03:38.260 --> 00:03:40.260
Então, o que isto significa

00:03:40.260 --> 00:03:43.260
é que o utilizador pode começar a ligar o que ele quer que os tijolos façam.

00:03:43.260 --> 00:03:45.260
O que estava a ser feito antes é integrado no sistema

00:03:45.260 --> 00:03:47.260
bem como o que dissemos que queríamos que fosse feito.

00:03:47.260 --> 00:03:49.260
E agora começa a mover-se em espaço tridimensional --

00:03:49.260 --> 00:03:51.260
para cima ou para baixo.

00:03:51.260 --> 00:03:54.260
Então, do lado esquerdo, [1,1] traduz-se em 0, ou seja, para baixo.

00:03:54.260 --> 00:03:56.260
Do lado direito,

00:03:56.260 --> 00:03:59.260
[0,0] é equivalente a 1, ou seja, para cima.

00:03:59.260 --> 00:04:01.260
E o que isso realmente significa

00:04:01.260 --> 00:04:03.260
é que as nossas estruturas agora contêm os diagramas

00:04:03.260 --> 00:04:05.260
do que queremos construir.

00:04:05.260 --> 00:04:08.260
Têm embutida toda a informação sobre o que foi construído.

00:04:08.260 --> 00:04:11.260
Isso significa que podemos ter alguma forma de auto-replicação.

00:04:11.260 --> 00:04:14.260
Neste caso eu chamo-lhe replicação autoguiada,

00:04:14.260 --> 00:04:16.260
porque a nossa estrutura contém os diagramas exactos.

00:04:16.260 --> 00:04:18.260
Se houver erros, pode-se substituir um componente.

00:04:18.260 --> 00:04:21.260
Toda a informação local está embutida para nos dizer como reparar.

00:04:21.260 --> 00:04:23.260
Por isso, poderíamos ter algo que subisse e lesse

00:04:23.260 --> 00:04:25.260
e pudesse devolver valores, um a um.

00:04:25.260 --> 00:04:27.260
Está embutido directamente; não há instruções externas.

00:04:27.260 --> 00:04:30.260
O último projecto que vou mostrar chama-se Biased Chains (cadeias tendenciosas),

00:04:30.260 --> 00:04:33.260
e é provavelmente o exemplo mais entusiasmante que temos de momento

00:04:33.260 --> 00:04:35.260
de sistemas passivos de automontagem.

00:04:35.260 --> 00:04:37.260
Ele pega na reconfigurabilidade

00:04:37.260 --> 00:04:39.260
e na programabilidade

00:04:39.260 --> 00:04:42.260
e transforma-as num sistema completamente passivo.

00:04:43.260 --> 00:04:45.260
Basicamente, temos uma cadeia de elementos.

00:04:45.260 --> 00:04:47.260
Cada elemento é completamente idêntico,

00:04:47.260 --> 00:04:49.260
e são tendenciosos.

00:04:49.260 --> 00:04:52.260
Cada cadeia, ou cada elemento, quer virar para a esquerda ou para a direita.

00:04:52.260 --> 00:04:55.260
Então, à medida que montamos a cadeia, estamos, basicamente, a programá-la.

00:04:55.260 --> 00:04:58.260
Estamos a dizer a cada unidade se deve virar à direita ou à esquerda.

00:04:58.260 --> 00:05:01.260
E quando se sacode a cadeia,

00:05:01.260 --> 00:05:03.260
ela dobra-se

00:05:03.260 --> 00:05:06.260
em qualquer configuração que tenhamos programado --

00:05:06.260 --> 00:05:08.260
neste caso, uma espiral,

00:05:08.260 --> 00:05:11.260
ou neste caso,

00:05:11.260 --> 00:05:14.260
dois cubos, lado a lado.

00:05:14.260 --> 00:05:16.260
Podemos basicamente programar

00:05:16.260 --> 00:05:18.260
qualquer forma tridimensional --

00:05:18.260 --> 00:05:21.260
ou unidimensional, bidimensional -- nesta cadeia completamente passiva.

00:05:21.260 --> 00:05:23.260
Então, o que nos diz isto sobre o futuro?

00:05:23.260 --> 00:05:25.260
Penso que nos diz que

00:05:25.260 --> 00:05:28.260
existem novas possibilidades para a automontagem, a replicação, a reparação

00:05:28.260 --> 00:05:31.260
nas nossas estruturas físicas, nos nossos edifícios, máquinas.

00:05:31.260 --> 00:05:33.260
Há nova programabilidade nestes componentes.

00:05:33.260 --> 00:05:35.260
E a partir daí temos novas possibilidades para a computação.

00:05:35.260 --> 00:05:37.260
Teremos computação espacial.

00:05:37.260 --> 00:05:39.260
Imaginem se os nossos edifícios, pontes, máquinas,

00:05:39.260 --> 00:05:41.260
todos os nossos tijolos pudessem realmente computar.

00:05:41.260 --> 00:05:43.260
Isso é um espantoso poder computacional paralelo e distribuído,

00:05:43.260 --> 00:05:45.260
novas possibilidades de design.

00:05:45.260 --> 00:05:47.260
Há um potencial entusiasmante nisto.

00:05:47.260 --> 00:05:49.260
Por isso, penso que estes projectos que vos mostrei

00:05:49.260 --> 00:05:51.260
são apenas um minúsculo passo na direcção deste futuro,

00:05:51.260 --> 00:05:53.260
se implementarmos estas novas tecnologias

00:05:53.260 --> 00:05:55.260
para um novo mundo automontado.

00:05:55.260 --> 00:05:57.260
Obrigado.

00:05:57.260 --> 00:05:59.260
(Aplausos)

